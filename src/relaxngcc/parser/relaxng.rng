<?xml version="1.0"?>
<!--
	TODO:
		due to a bug in the classic parser wrt  handling QName, we don't use
		QNames for now. Once the new parser becomes stable, modify this grammar
		to use QName (such as <element name="cc:java-import">)
-->
<!DOCTYPE grammar [
	<!ENTITY ccNSURI "http://www.xml.gr.jp/xmlns/relaxngcc">
]>
<grammar datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes"
         ns="http://relaxng.org/ns/structure/1.0"
         xmlns="http://relaxng.org/ns/structure/1.0"
         xmlns:cc="&ccNSURI;"
         
         cc:runtime-type="relaxngcc.parser.ParserRuntime"
         cc:package="relaxngcc.parser.state">
  
  <cc:java-import>
    import relaxngcc.grammar.*;
  </cc:java-import>
  
  <start cc:class="Start" cc:access="public">
    <cc:java-body>
      public Pattern getResult() { return result; }
    </cc:java-body>
    <ref name="pattern" cc:alias="result"/>
  </start>
  
  <!-- name for an attribute/element -->
  <define name="name" cc:params="boolean attributeMode"
    cc:return-type="NameClass" cc:return-value="nc">
    <choice>
      <attribute name="name">
        <data type="QName" cc:alias="name" />
        <cc:java>nc = runtime.parseSimpleName(name,attributeMode);
        </cc:java>
      </attribute>
      <ref name="name-class" cc:alias="nc" />
    </choice>
  </define>
  
  <define name="pattern" cc:class="PatternState"
    cc:return-type="Pattern" cc:return-value="p">
    <choice>
      <element name="element">
        <ref name="name" cc:alias="name" cc:with-params="false" />
        <ref name="patterns" cc:alias="p"/>
        <cc:java>
          p = new ElementPattern(name,p);
        </cc:java>
      </element>
      <element name="attribute">
        <ref name="name" cc:alias="name" cc:with-params="true" />
        <optional>
          <ref name="patterns" cc:alias="p"/>
        </optional>
        <cc:java>
          // if there is no child pattern, assume &lt;text>.
          if(p==null)  p = new DataPattern(null);
          p = new AttributePattern(name,p);
        </cc:java>
      </element>
      <element name="group">
        <ref name="patterns" cc:alias="p" />
      </element>
      <element name="interleave">
        <oneOrMore>
          <ref name="pattern" cc:alias="child"/>
          <cc:java>
            if(p==null)  p = child;
            else         p = new InterleavePattern(p,child);
          </cc:java>
        </oneOrMore>
      </element>
      <element name="choice">
        <oneOrMore>
          <ref name="pattern" cc:alias="child"/>
          <cc:java>
            if(p==null)  p = child;
            else         p = new ChoicePattern(p,child);
          </cc:java>
        </oneOrMore>
      </element>
      <element name="optional">
        <ref name="patterns" cc:alias="p" />
        <cc:java>
          p = new ChoicePattern( p, EmptyPattern.theInstance );
        </cc:java>
      </element>
      <element name="zeroOrMore">
        <ref name="patterns" cc:alias="p" />
        <cc:java>
          p = new ChoicePattern( new OneOrMorePattern(p),
              EmptyPattern.theInstance );
        </cc:java>
      </element>
      <element name="oneOrMore">
        <ref name="patterns" cc:alias="p" />
        <cc:java>
          p = new OneOrMorePattern( p );
        </cc:java>
      </element>
      <element name="list">
        <ref name="patterns" cc:alias="p" />
        <cc:java>
          p = new ListPattern( p );
        </cc:java>
      </element>
      <element name="mixed">
        <ref name="patterns" cc:alias="p" />
        <cc:java>
          p = new InterleavePattern( new DataPattern(null), p );
        </cc:java>
      </element>
      <element name="ref">
        <ref name="NGCC-call" cc:alias="params" />
        <attribute name="name">
          <text cc:alias="target" />
        </attribute>
        <cc:java>
          p = new RefPattern(runtime.grammar.getOrCreate(target),params);
        </cc:java>
      </element>
      <element name="parentRef">
        <ref name="NGCC-call" cc:alias="params" />
        <attribute name="name">
          <text cc:alias="target" />
        </attribute>
        <cc:java>
          // refers to the parent grammar,
          // instead of the current grammar
          p = new RefPattern(
              runtime.grammar.parent.getOrCreate(target),params);
        </cc:java>
      </element>
      <element name="empty">
        <empty/>
        <cc:java>
          p = EmptyPattern.theInstance;
        </cc:java>
      </element>
      <element name="text">
        <empty/>
        <ref name="NGCC-call" cc:alias="params" />
        <cc:java>
          p = new DataPattern(params);
        </cc:java>
      </element>
      <element name="value">
        <optional><!-- we can't handle types other than 'token' -->
          <attribute name="type">
            <value>token</value>
          </attribute>
        </optional>
        <ref name="NGCC-call" cc:alias="params" />
        <text cc:alias="value"/>
        <cc:java>
          p = new ValuePattern(value,params);
        </cc:java>
      </element>
      <element name="data">
        <attribute name="type">
          <data type="NCName"/>
        </attribute>
        <zeroOrMore>
          <element name="param">
            <attribute name="name" />
            <text/>
          </element>
        </zeroOrMore>
        <!--optional>
          <element name="except">
            <ref name="patterns"/>
          </element>
        </optional-->
        <ref name="NGCC-call" cc:alias="params" />
        <cc:java>
          p = new DataPattern(params);
        </cc:java>
      </element>
      <element name="notAllowed">
        <empty/>
        <cc:java>
          p = NotAllowedPattern.theInstance;
        </cc:java>
      </element>
      <!--element name="externalRef">
        <attribute name="href">
          <data type="anyURI"/>
        </attribute>
        <ref name="common-atts"/>
        <ref name="other"/>
      </element-->
      <element name="grammar">
        <cc:java>
          runtime.grammar = new Grammar( runtime.grammar );
        </cc:java>
        <ref name="grammar-content" />
        <cc:java>
          // behave as if there is an implicit ref
          // between &lt;grammar> and its  parent.
          p = new RefPattern( runtime.grammar, null );
          // get back to the parent context
          runtime.grammar = runtime.grammar.parent;
        </cc:java>
      </element>
      <element name="java" ns="&ccNSURI;">
        <text cc:alias="value"/>
        <cc:java> p = new JavaBlock(value); </cc:java>
      </element>
    </choice>
  </define>

  <define name="grammar-content" cc:class="GrammarContent">
    <zeroOrMore>
      <choice>
        <ref name="start-element"/>
        <ref name="define-element"/>
        <element name="div">
          <ref name="grammar-content"/>
        </element>
        <element name="java-import" ns="&ccNSURI;">
          <text cc:alias="value"/>
          <cc:java>
            runtime.appendGlobalImports(value);
          </cc:java>
        </element>
        <element name="include">
          <attribute name="href">
            <text cc:alias="href" />
          </attribute>
          <cc:java>
            runtime.processInclude(href);
          </cc:java>
          <!-- TODO: support redefinition -->
          <!--ref name="include-content"/-->
        </element>
      </choice>
    </zeroOrMore>
  </define>

  <!--define name="include-content">
    <zeroOrMore>
      <choice>
        <ref name="start-element"/>
        <ref name="define-element"/>
        <element name="div">
          <ref name="include-content"/>
        </element>
      </choice>
    </zeroOrMore>
  </define-->

  <define name="start-element" cc:class="StartElement">
    <element name="start">
      <ref name="pattern-definition"
        cc:with-params="runtime.grammar"/>
    </element>
  </define>
  
  <define name="define-element" cc:class="DefineElement">
    <element name="define">
      <attribute name="name">
        <text cc:alias="name"/>
      </attribute>
      <ref name="pattern-definition"
        cc:with-params="runtime.grammar.getOrCreate(name)"/>
    </element>
  </define>
  
  <define name="pattern-definition" cc:class="PatternDefinition"
    cc:params="Scope scope">
    <optional>
      <attribute name="combine">
        <text cc:alias="combine" />
      </attribute>
    </optional>
    <optional>
      <element name="java-import" ns="&ccNSURI;">
        <text cc:alias="value"/>
        <cc:java>
          scope.appendImport(value);
        </cc:java>
      </element>
    </optional>
    
    <!-- TODO: interleave -->
    <zeroOrMore>
      <element name="java-body" ns="&ccNSURI;">
        <text cc:alias="value"/>
        <cc:java>
          scope.appendBody(value);
        </cc:java>
      </element>
    </zeroOrMore>
    <ref name="patterns" cc:alias="p"/>
    <cc:java>
      scope.append(p,combine);
    </cc:java>
    <zeroOrMore>
      <element name="java-body" ns="&ccNSURI;">
        <text cc:alias="value"/>
        <cc:java>
          scope.appendBody(value);
        </cc:java>
      </element>
    </zeroOrMore>
  </define>
  
  
  <!-- sequence of patterns combined by Group -->
  <define name="patterns" cc:return-type="Pattern" cc:return-value="p">
    <cc:java-body>
      private Pattern p=null;
    </cc:java-body>
    <oneOrMore>
      <ref name="pattern" cc:alias="child"/>
      <cc:java>
        if(p==null)  p = child;
        else         p = new GroupPattern(p,child);
      </cc:java>
    </oneOrMore>
  </define>

  <define name="name-class" cc:class="NameClassState"
    cc:return-type="NameClass" cc:return-value="nc">
    
    <cc:java-body>
      private NameClass nc;
    </cc:java-body>
    
    <choice>
      <element name="name">
        <text cc:alias="name"/>
        <cc:java>
          nc = runtime.parseSimpleName(name,false);
        </cc:java>
      </element>
      <element name="anyName">
        <ref name="except-name-class" cc:alias="child"/>
        <cc:java>
          nc = new AnyNameClass(child);
        </cc:java>
      </element>
      <element name="nsName">
        <ref name="except-name-class" cc:alias="child"/>
        <cc:java>
          nc = new NsNameClass(runtime.getTargetNamespace(),child);
        </cc:java>
      </element>
      <element name="choice">
        <ref name="name-classes" cc:alias="nc"/>
      </element>
    </choice>
  </define>

  <define name="except-name-class" cc:class="ExceptNameClass"
    cc:return-type="NameClass" cc:return-value="nc">
    
    <optional>
      <element name="except">
        <ref name="name-classes" cc:alias="nc"/>
      </element>
    </optional>
  </define>

  <define name="name-classes" cc:class="NameClasses"
    cc:return-type="NameClass" cc:return-value="nc">
    
    <cc:java-body>
      private NameClass nc=null;
    </cc:java-body>
    
    <oneOrMore>
      <ref name="name-class" cc:alias="child" />
      <cc:java>
        if(nc==null)  nc=child;
        else          nc=new ChoiceNameClass(nc,child);
      </cc:java>
    </oneOrMore>
  </define>
  
  
  
  
  <!-- NGCC attributes -->
  <define name="NGCC-call" cc:class="NGCCcall"
    cc:return-type="NGCCCallParam" cc:return-value="param">
    
    <cc:java-body>
      NGCCCallParam param;
    </cc:java-body>
    <optional>
      <attribute name="cc:with-params">
        <text cc:alias="withParams"/>
      </attribute>
    </optional>
    <optional>
      <attribute name="cc:alias">
        <text cc:alias="alias"/>
      </attribute>
    </optional>
    <cc:java>
      param = new NGCCCallParam(withParams,alias);
    </cc:java>
  </define>
</grammar>
