<html>
<head>
	<title>RelaxNGCC チュートリアル２</title>
	<link rel="stylesheet" href="ngcc.css">
	<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=shift_jis">
</head>
<body>
<h1>RelaxNGCC チュートリアル２</h1>
<p>
　チュートリアル１よりもう少し複雑な例を見てみます。
</p>
<h2>スキーマの説明</h2>
<p>
　このチュートリアルで取り上げるスキーマは、あるディレクトリ以下のディレクトリとファイルの構造を表現したものです。以下のようになります。赤いところはRelaxNGCCのためのマークアップ部分です。青い数字は後述する説明に使います。

</p>
<pre>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;grammar xmlns="http://relaxng.org/ns/structure/1.0"
  datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes"
  xmlns:c="http://www.xml.gr.jp/xmlns/relaxngcc"&gt;

<span class="remark">[1]</span>
<span class="emph-code">&lt;c:java-import&gt;
import java.util.Set;
import java.util.HashSet;
&lt;/c:java-import&gt;</span>

&lt;start <span class="emph-code">c:class="sample2"</span>&gt;
  <span class="remark">[2]</span>
  <span class="emph-code">&lt;c:java-body&gt;
  public Set hiddenfiles;
  &lt;/c:java-body&gt;</span>
  &lt;element name="files"&gt;
    &lt;ref name="file-or-dir" <span class="emph-code">c:alias="child"</span>/&gt;
    <span class="remark">[3]</span>
    <span class="emph-code">&lt;c:java&gt;hiddenFiles = new HashSet(child.hiddenFiles);&lt;/c:java&gt;</span>
  &lt;/element&gt;
&lt;/start&gt;

<span class="remark">[4]</span>
&lt;define name="file-or-dir" <span class="emph-code">c:class="FileOrDir"</span>&gt;
  <span class="emph-code">&lt;c:java-body&gt;
  public Set hiddenFiles;
  &lt;/c:java-body&gt;</span>
  <span class="emph-code">&lt;c:java&gt;hiddenFiles = new HashSet();&lt;/c:java&gt;</span>
  &lt;oneOrMore&gt;
    &lt;choice&gt;
      &lt;element name="file"&gt;
        &lt;attribute name="name"&gt;
          &lt;text <span class="emph-code">c:alias="filename"</span>/&gt;
          <span class="remark">[5]</span>
          <span class="emph-code">&lt;c:java&gt;if(filename.startsWith(".")) hiddenFiles.add(filename);&lt;/c:java&gt;</span>
        &lt;/attribute&gt;
      &lt;/element&gt;
      &lt;element name="directory"&gt;
        &lt;attribute name="name"&gt;&lt;text/&gt;&lt;/attribute&gt;
        &lt;ref name="file-or-dir" <span class="emph-code">c:alias="content"</span>/&gt;
        <span class="remark">[6]</span>
        <span class="emph-code">&lt;c:java&gt;hiddenFiles.add(content.hiddenFiles);&lt;/c:java&gt;</span>
      &lt;/element&gt;
    &lt;/choice&gt;
  &lt;/oneOrMore&gt;
&lt;/define&gt;

&lt;/grammar&gt;
</pre>

<p>
　このように、このスキーマではルートに<tt>files</tt>エレメントが来て、その下に<tt>directory</tt>または<tt>file</tt>が来ます。<tt>directory</tt>の下にも<tt>directory</vまたは<tt>file</tt>が来ます。
</p>
<h2>RelaxNGCC マークアップ</h2>
<p>
　さて、このスキーマに則ったXML文書を読むとき、ピリオドで始まるファイル(Unixでは隠し属性のファイル)のみを集めてきたいと思ったとしましょう。ディレクトリ構造は無視して、ファイル名だけのコレクションを得ることが目的であるとします。

</p>

<p>　以下、各部分についての説明です。</p>

<p><span class="remark">[1]</span>
 <tt>java-import</tt>の中に書いた文は、Javaのクラス定義の本体の外側に出力されます。javaエレメントや<tt>java-body</tt>で使用するコードが<tt>import</tt>文を必要とするならこの位置に書いてください。即ち<tt>import</tt>文とコメントが書けることになります。packageの指定はgrammarエレメントのアトリビュートで行うので、<tt>java-import</tt>内に書くことはできません。なお、<tt>java-import</tt>は、grammarの直下に置いた場合出力されるすべてのJavaファイルに適用されます。単一のファイルに適用するときには対応する<tt>start</tt>または<tt>define</tt>エレメントの直下に置いてください。

</p>

<p><span class="remark">[2]</span>
 <tt>java-body</tt>は、生成されるJavaコードに追加的なデータメンバやメソッドを定義したいときに使います。ここでは、ファイル名を収録するために<tt>hiddenFiles</tt>という名前のメンバを宣言しています。

</p>
<p><span class="remark">[3]</span>
 <tt>java</tt>エレメントは、XML文書を読んでスキーマの該当する位置に来たとき実行するコードを記述します。ここでは、ルートエレメントである<tt>files</tt>が終わったら、hiddenFilesを設定しています。
</p>

<p><span class="remark">[4]</span>
　RelaxNGCCは、このブロック単位で対応する１個のJavaファイルを生成するので、このサンプルではJavaファイルは２つ生成されることになります。このクラス名を指定するのが、start、defineそれぞれに追加されたアトリビュート c:class です。特に、define側ではその名前がfile-or-dirでハイフンを含んでいるためそのままではJavaのクラス名としては不正です。そのようなときは<tt>c:class</tt>が必須になります。

</p>

<p><span class="remark">[5]</span>
 ピリオドで始まるファイル名であればコレクションに格納しています。
</p>

<p><span class="remark">[6]</span>
 これも<tt>java</tt>エレメントですが、直前の<tt>ref</tt>エレメントにあるaliasを参照しているところに注意してください。<tt>ref</tt>エレメントに<tt>alias</tt>をつけると、それは<tt>ref</tt>エレメントが参照する<tt>define</tt>ブロックに対応したRelaxNGCCのオブジェクトになります。つまりこの例では、file-or-dirブロックに対応するFileOrDirオブジェクトということになります。

</p>

<p>
　最終的にRelaxNGCCが出力したJavaファイルをコンパイル・実行すると、startエレメントに対応したオブジェクトの<tt>hiddenFiles</tt>メンバにすべての隠し属性ファイルが収録されます。起動手順は出力したファイルの中の<tt>main()<tt>関数を参照してください。
</p>

<h2>Relaxerとの比較</h2>
<p>
　文法からJavaのソースコードを出力する点では、RelaxNGCCとRelaxerは同じです。ですが、例えばこのサンプルで出したような目的でXML文書を読みたい場合、Relaxerを使ってXML文書を読み込ますと本来不要なdirectoryに対応したオブジェクトまでできてしまいます。もっと限定した情報がほしい場合、Relaxerの出力したオブジェクトモデルにアクセスしていかなければなりません。これに対しRelaxNGCCでは、すべてがSAXベースの１パスで処理が完了するため効率的です。

</p>
<p>
　ただしJavaオブジェクトからXMLへの変換など、RelaxerにあってRelaxNGCCにない機能もあります。目的に応じて使い分ければよいでしょう。
</p>
<hr>
<p align="right"><a href="index_ja.htm">RelaxNGCC home</a></p>
</body>
</html>