<html>
<head>
	<title>RelaxNGCC <?ja?>マニュアル<?/ja?><?en?>manual<?/en?></title>
	<link rel="stylesheet" href="ngcc.css"/>
	<?ja?><meta HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=shift_jis"><?/ja?>
</head>
<body>
<a name="top">
<h1>RelaxNGCC <?ja?>マニュアル<?/ja?><?en?>Manual<?/en?></h1>
<div align="right">Last update <?ja?>2002/05/03<?/ja?><?en?>May 3, 2002<?/en?></div>
<div><?ja?>もくじ<?/ja?><?en?>Contents<?/en?></div>
<ul>
<li><a href="#scope"><?ja?>スコープ<?/ja?><?en?>Scopes<?/en?></a></li>
<li><a href="#markup"><?ja?>マークアップ<?/ja?><?en?>Mark-ups<?/en?></a></li>
<li><a href="#modes"><?ja?>動作モード<?/ja?><?en?>Operation Modes<?/en?></a></li>
<li><a href="#usage"><?ja?>生成したコードの使い方<?/ja?><?en?>Usage of the Generated Code<?/en?></a></li>
<li><a href="#typemap"><?ja?>型の対応表<?/ja?><?en?>Type Correspondence Table<?/en?></a></li>
<li><a href="#restrictions"><?ja?>制約事項<?/ja?><?en?>Restrictions<?/en?></a></li>
<li><a href="#tbd"><?ja?>未サポート機能<?/ja?><?en?>Unsupported Features<?/en?></a></li>
</ul>

<a name="scope">
<h2>1 <?ja?>スコープ<?/ja?><?en?>Scopes<?/en?></h2>
<p><?ja?>　RelaxNGCCにとって、スコープという概念が重要です。RelaxNGCCは次のルールでスコープを生成し、スコープ１つに対して１つのJavaのクラスを生成します。<?/ja?><?en?>Scopes are important concept for RelaxNGCC. It generates scopes along following rules and outputs a Java class for each scope.<?/en?></p>
<ul>
<li><?ja?>それぞれのdefineブロック(startエレメントによるものも含む)が１スコープに対応します。<?/ja?><?en?>Each <tt>define</tt> block or <tt>start</tt> block corresponds to a scope.<?/en?></li>
<li><?ja?>ただし、<tt>class</tt>アトリビュート(後述)がついている要素を単独のスコープとして分離します。<?/ja?><?en?>However, elements with <tt>class</tt> attributes (described later) are separated into independent scopes.<?/en?></li>
<li><?ja?>さらに、defineエレメントに<tt>inline</tt>アトリビュートがついているとそのスコープはインライン展開され、別のスコープにとりこまれます。<?/ja?><?en?>Additionally, <tt>define</tt> elements with <tt>inline</tt> attributes are expanded into other scopes.<?/en?></li>
</ul>
<p><?ja?>例えば、次の文法は１つの<tt>start</tt>エレメント、２つの<tt>define</tt>エレメントを含んでいるので３つのスコープが生成されます。<?/ja?><?en?>For example, RelaxNGCC produces 3 scopes from the next grammar since it contains 1 <tt>start</tt> element and 2 <tt>define</tt> elements.<?/en?>
<pre>
&lt;grammar xmlns="http://relaxng.org/ns/structure/1.0"&gt;
  &lt;start&gt;
    ...
  &lt;/start&gt;
  &lt;define name="A"&gt;
    ...
  &lt;/define&gt;
  &lt;define name="B"&gt;
    ...
  &lt;/define&gt;
&lt;/grammar&gt;
</pre>

<a name="markup">
<h2>2 <?ja?>マークアップ<?/ja?><?en?>Mark-ups<?/en?></h2>
<p><?ja?>　RelaxNGCC独自のマークアップはすべて<br><br><tt style="font-weight:bold;">http://www.xml.gr.jp/xmlns/relaxngcc</tt><br><br>のnamespace-URIを持ちますが、このマニュアルではプレフィックス "<tt>c</tt>" を使用しています。マークアップは次に説明するように３種のエレメントと５種のアトリビュートから構成されます。<?/ja?>
<?en?> The extended mark-ups peculiar to RelaxNGCC have the namespace-URI <br><br><tt style="font-weight:bold;">http://www.xml.gr.jp/xmlns/relaxngcc</tt>, while the namespace is represented by prefix "<tt>c</tt>" in this manual.<br><br>They consist of following 3 kinds elements and 5 kinds attributes.<?/en?></p>

<h3>2.1 <?ja?><tt>alias</tt>アトリビュート<?/ja?><?en?><tt>alias</tt> attribute<?/en?></h3>
<p><?ja?>　ユーザ定義のコードからアクセスするために、データに名前をつけます。このアトリビュートをつけることのできるRELAX NGのエレメントは、<tt>data</tt>, <tt>text</tt>, <tt>ref</tt>, <tt>value</tt>, <tt>list</tt>の５つです。<?/ja?>
<?en?> We can use this attribute to refer to data from the user-defined code in <tt>java</tt> elements. The <tt>alias</tt> attribute is applicable to the <tt>data</tt>, <tt>text</tt>, <tt>ref</tt>, <tt>value</tt>, <tt>list</tt> elements of RELAX NG.<?/en?>
</p>
<pre>
&lt;data type="nonNegativeInteger" <span class="emph-code">c:alias="count"</span>/&gt;
</pre>
<p><?ja?>　aliasをつけたデータがJavaのオブジェクトとして何になるかは次の表のようにして決まります。<?/ja?>
<?en?> The type of the Java object named by the <tt>alias</tt> attribute is fixed by the following table.<?/en?>
</p>
<table border="1">
<tr><th>RELAX NG element</th><th>type</th></tr>
<tr><td><tt>data</tt></td><td>String (<a href="#modes">plain sax <?en?>mode<?/en?><?ja?>モード<?/ja?></a>), <?en?>otherwise <br>depends on datatype(other mode)<?/en?><?ja?>または<br>データ型に依存(その他のモード)<?/ja?>(*1)</td></tr>
<tr><td><tt>text</tt></td><td>String</td></tr>
<tr><td><tt>ref</tt></td><td><?en?>The class generated by RelaxNGCC for the destination scope of the reference.<?/en?><?ja?>このrefが参照する先のスコープに対応した、RelaxNGCCの生成したクラス<?/ja?></td></tr>
<tr><td><tt>value</tt></td><td>String</td></tr>
<tr><td><tt>list</tt></td><td>String (*2)</td></tr>
</table>
<p><?ja?>(*1) <tt>data</tt>の<tt>type</tt>アトリビュートに依存します。後述の<a href="#typemap">表</a>を参照してください。なお、RELAX NGはXML Schema Part2以外のデータ型を使うことも可能な設計になっていますが、RelaxNGCCは現在XML Schema Part2のみをサポートします。<br>(*2)<tt>list</tt>エレメントに<tt>alias</tt>をつけたときには全体が１個の文字列として扱われます。空白文字による分割は行われません。<?/ja?>
<?en?> (*1) The type depends on <tt>type</tt> attribute of the <tt>data</tt> element. The <a href="#typemap">table</a> in this document describes the correspondence. Although RELAX NG has the design that can use datatypes other than XML Schema Part2, RelaxNGCC supports only XML Schema Part 2.<br> (*2) If you place the <tt>alias</tt> attribute with a <tt>list</tt> element, the entire of the data that matches the <tt>list</tt> element is dealed as a string. RelaxNGCC does not split the data into whitespace-separated sequence of tokens.<?/en?>
</p>
<p><?ja?>　RelaxNGCCの出力するソースコードはSAXベースであるため、aliasアトリビュートでつけた名前は生成されるクラスのデータメンバとして割り当てられます。従って、１つのスコープ内で同じ名前をaliasに付けることはできません。出力されたソースがコンパイルできなくなってしまいます。<?/ja?><?en?> Since the code generated by RelaxNGCC conforms to the SAX interface, the names declared by <code>alias</code> attributes become data members of the generated class. Therefore identical names must not exist in a scope. If the programmer break this rule, the generated code will fail to compile.<?/en?>

<h3>2.2 <?ja?><tt>java</tt>エレメント<?/ja?><?en?><tt>java</tt> element<?/en?></h3>
<p>
<?ja?>　ユーザ定義のJavaコードを記述します。コードの断片には<tt>alias</tt>アトリビュートで定義した名前を使うことができます。記述したコードは、入力XMLの該当個所を読んだところで実行されます。<?/ja?>
<?en?> You can write a code fragment of Java in the <tt>java</tt> element. In this fragment, you can refer to the data of the XML instance by variables defined with the <tt>alias</tt> attribite. The content of <tt>java</tt> element is executed during the parse of the input. <?/en?><br>
<pre>
&lt;element name="name"&gt;
  &lt;text <span class="emph-code">c:alias="name"</span>/&gt;
  <span class="emph-code">&lt;c:java&gt;System.out.println(name);&lt;/c:java&gt;</span>
&lt;/element&gt;
</pre>
<p>
<?ja?>　生成されたコードは最終的にはSAX2ベースの処理になるので、外に投げることのできる例外はSAXExceptionとその派生クラスに限られます。<?/ja?>
<?en?> Since the code generated by RelaxNGCC conforms to the SAX2 interface, only <tt>SAXException</tt> or its derivative exceptions can be thrown in the <tt>java</tt> element.<?/en?>
</p>
<p>
<?ja?>　<tt>java</tt>エレメントはスコープ内のどこにでも書くことができます。書いた場所とそれが実行されるタイミングとの関係についての詳細なドキュメントは今後準備する予定です。<?/ja?>
<?en?> The <tt>java</tt> element can appear any location of the scope. A detailed document about the location of <tt>java</tt> element and the execution condition will be available later.<?/en?>
</p>
<p>
<?ja?>　なおエレメント名に<tt>java</tt>を使っている理由は、将来他のプログラム言語（例えばC#）にも対応するかもしれないからです。<?/ja?>
<?en?> Note that the reason for using "<tt>java</tt>" for the element name is that RelaxNGCC may support other program languages (for example, C#) besides the future.<?/en?>
</p>

<h3>2.3 <?ja?><tt>java-body</tt>エレメント<?/ja?><?en?><tt>java-body</tt> element<?/en?></h3>
<p>
<?ja?>　生成されるクラスについて、補助的に使用するメソッドやデータメンバを記述します。ここで定義したものはjavaエレメント内のコードからアクセスできます。<?/ja?>
<?en?> You can write methods and data members of generated classes using <tt>java-body</tt> element. Since RelaxNGCC copies the content of the <tt>java-body</tt> into the Java code, you can refer to the methods and the data members from your code in all <tt>java</tt> elements.<br><?/en?>
<pre>
&lt;define name="x"&gt;
  <span class="emph-code">&lt;c:java-body&gt;
  private void echo(String msg)
  { System.out.println(msg); }
  &lt;/c:java-body&gt;</span>
  ...
&lt;/define&gt;
</pre>
<p>
<?ja?>　たとえばこのようにすると、この<tt>define</tt>ブロックの<tt>java</tt>エレメント内から<tt>echo</tt>メソッドが使えるようになります。<?/ja?>
<?en?> For example, the <tt>echo</tt> method is available from all the <tt>java</tt> elements in the <tt>define</tt> block. <?/en?>
</p>
<p>
<?ja?>　<tt>java-body</tt>エレメントは、次の場所に書くことができます。<?/ja?>
<?en?> A <tt>java-body</tt> element is allowed only following locations:<?/en?>
<dl>
<dt>a. <?ja?><tt>grammar</tt>エレメントの直下<?/ja?><?en?>under <tt>grammar</tt> element<?/en?></dt>
<dd><?ja?>RelaxNGCCが生成するすべてのクラスのコードに、java-body内のコードが挿入されます。<?/ja?><?en?>The content of <tt>java-body</tt> is inserted into all classes generated by RelaxNGCC.<?/en?></dd>
<dt>b. <?ja?><tt>start</tt>, <tt>define</tt>エレメントの直下<?/ja?><?en?>under <tt>start</tt> or <tt>define</tt> element<?/en?></dt>
<dd><?ja?>その<tt>start/define</tt>エレメントに対応して生成されるクラスのコードにのみ挿入されます。<?/ja?><?en?>The content of <tt>java-body</tt> is inserted into only the class corresponding to the <tt>start</tt> or <tt>define</tt> element.<?/en?></dd>
</dl>
<h3>2.4 <?ja?><tt>java-import</tt>エレメント<?/ja?><?en?><tt>java-import</tt> element<?/en?></h3>
<p>
<?ja?>　<tt>java-body</tt>と違い、ソースコード中のクラス定義本体の外に記述するコードを記述します。ふつうJavaのimport宣言を記述します。これを置くことのできる位置と効果はjava-bodyと同じです。<?/ja?>
<?en?> Unlike <tt>java-body</tt>, the content of <tt>java-import</tt> element is copied outside of the definition of the class. In common case, you would write import declarations in the <tt>java-import</tt> element. The allowed location of <tt>java-import</tt> is same as <tt>java-body</tt>. <?/en?>
</p>
<pre>
<span class="emph-code">&lt;c:java-import&gt;
import java.util.Set;
import java.util.Iterator;
&lt;/c:java-import&gt;</span>
</pre>
<h3>2.5 <?ja?><tt>class</tt>アトリビュート<?/ja?><?en?><tt>class</tt> attribute<?/en?></h3>
<p>
<?ja?>　<tt>start</tt>エレメント、<tt>define</tt>エレメントに記述して、それに対応するクラスの名前を指定します。Javaのクラス名として正しい文字列を指定する必要があります。省略時には、RelaxNGCCが適当な名前をつけてソースコードを生成します。<?/ja?>
<?en?> The <tt>class</tt> attribute appears at a <tt>start</tt> element or a <tt>define</tt> element, and defines the name of generated Java class. The value of <tt>class</tt> attribute must be valid as a name of a Java class. If it is omitted, RelaxNGCC gives a suitable name for the class.<?/en?>
<pre>
&lt;start <span class="emph-code">c:class="Root"</span>&gt;
...
&lt;/start&gt;
</pre>
<p>
<?ja?>　さらに、<tt>element</tt>、<tt>oneOrMore</tt>のようなRELAX NGの文法要素に<tt>class</tt>アトリビュートを書くこともできます。こうした場合には、アトリビュートを付加した要素に対応する部分を読むコードがJavaクラスとして切り出されます。このクラスはそれを囲む<tt>define/start</tt>エレメントに対応したクラスの内部クラスになるので、外のクラスのインスタンス変数にアクセスすることができます。<?/ja?>
<?en?> Additionally, the <tt>class</tt> attribute can appear at some RELAX NG elements such as <tt>element</tt> element or <tt>oneOrMore</tt> element. In this case, the corresponding block enclosed by the RELAX NG element is chopped off into a Java class. Since the class is located in the inner-class of the class for parent <tt>define</tt>/<tt>start</tt> element, you can access data members of the parent class including data named via <tt>alias</tt> attribute.<?/en?>
<pre>
&lt;define name="parent"&gt;
  &lt;c:body&gt;
  Set _Items = new HashSet();
  &lt;/c:body&gt;
  &lt;zeroOrMore <span class="emph-code">c:class="Item" c:alias="item"</span>&gt;
    &lt;data type="string" c:alias="_uri"/&gt;
    &lt;data type="string" c:alias="_location"/&gt;
    &lt;c:java&gt;
     _Items.add(this);
    &lt;/c:java&gt;
  &lt;/zeroOrMore&gt;
&lt;/define&gt;
</pre>

<p><?ja?>　なお、<tt>combine</tt>アトリビュートのついた<tt>define</tt>エレメントについては、結合先の<tt>define</tt>ブロックとマージされてひとつのクラスになるので、<tt>class</tt>アトリビュートは無視されます。<?/ja?><?en?>Note that the <tt>class</tt> attribute is ignored when the <tt>define</tt> element has <tt>combine</tt> attribute because the <tt>define</tt> block is merged into other block.<?/en?></p>

<h3>2.6 <?ja?><tt>inline</tt>アトリビュート<?/ja?><?en?><tt>inline</tt> attribute<?/en?></h3>
<p>
<?ja?>　スコープをインライン展開することを指定します。<tt>define</tt>エレメントに記入します。<span style="text-decoration:underline">特にテキストのみからなるスコープは、RelaxNGCCの都合上インライン展開しないと処理がうまくできないので注意が必要です。</span><?/ja?>
<?en?> The <tt>inline</tt> attribute can appear in <tt>define</tt> elements and indicates that the scope is expanded into other scopes refering to it. <span style="text-decoration:underline">Especially scopes that consists of only text elements must be expanded</span>. This is a restriction of RelaxNGCC.<?/en?>
</p>
<pre>
&lt;define name="block" <span class="emph-code">c:inline="true"</span>&gt;
...
</pre>

<h3>2.7 <?ja?><tt>package</tt>アトリビュート<?/ja?><?en?><tt>package</tt> attribute<?/en?></h3>
<p>
<?ja?>　生成するソースコードがどのパッケージに属すかを指定します。<tt>grammar</tt>エレメントに記入します。この宣言は生成されるすべてのクラスにおいて共通です。<?/ja?>
<?en?> The <tt>package</tt> attribute can appear on the top <tt>grammar</tt> element of RELAX NG and defines the Java package name of generated classes.<?/en?>
</p>
<pre>
&lt;grammar ... <span class="emph-code">c:package="com.example.project1"</span>&gt;
...
</pre>
<h3>2.8 <?ja?><tt>access</tt>アトリビュート<?/ja?><?en?><tt>access</tt> attribute<?/en?></h3>
<p>
<?ja?>　生成するソースコードのアクセス修飾子("public final"など)を指定します。このアトリビュートは<tt>define</tt>エレメント、<tt>start</tt>エレメント、<tt>class</tt>アトリビュートを書いたエレメントに書くことができます。<?/ja?>
<?en?> The <tt>access</tt> attribute declares the access modifiers (i.e. "public final") for generated Java class. This attribute can appear in <tt>define</tt> elements, <tt>start</tt> elements, and any elements with <tt>class</tt> attribute.<?/en?>
</p>
<pre>
&lt;start <span class="emph-code">c:class="sample1"</span> <span class="emph-code">c:access="public final"</span>&gt;
...
&lt;/start&gt;
</pre>

<a name="modes">
<h2>3 <?ja?>RelaxNGCCの動作モード<?/ja?><?en?>Operation Modes of RelaxNGCC<?/en?></h2>
<p>
<?ja?>　RelaxNGCCでは、出力するソースコードのスタイルを３通りから選べます。それぞれの比較は次のようになります。<?/ja?>
<?en?> In RelaxNGCC, you can choose the style of generated Java source code from three kinds. The features of the three styles are following.<?/en?>
</p>
<table border="1" width="100%">
  
  <tr><th width="25%">&nbsp;</th><th width="25%"><?ja?>MSVモード<?/ja?><?en?>MSV mode<?/en?></th><th width="25%"><?ja?>Typed SAXモード<?/ja?><?en?>Typed SAX mode<?/en?></th><th width="25%"><?ja?>プレーンSAXモード<?/ja?><?en?>plain SAX mode<?/en?></th></tr>
  
  <tr><td><?ja?>RelaxNGCCの起動オプション<?/ja?><?en?>RelaxNGCC options<?/en?></td><td><tt>--msv</tt></td><td><tt>--typedsax</tt></td><td><tt><?ja?>デフォルトです<?/ja?><?en?>(default)<?/en?></tt></td></tr>
  
  <tr>
    <td><?ja?>概要<?/ja?><?en?>Description<?/en?></td>
    <td><?ja?>入力のXML文書はまずMSV(*1)に渡り、次にRelaxNGCCで生成したコードにTypedContentHandlerインタフェース経由で渡ります。<?/ja?><?en?>The input XML instance is checked by the RELAX NG implementation of MSV at first, and the generated code receives it via <tt>TypedContentHandler</tt> interface later.<?/en?></td>
    <td><?ja?>データ型チェックのためにMSV内のデータタイプライブラリを使用します。文書はMSVを介さないでSAX2経由で読まれます。<?/ja?><?en?>The MSV is used for only datatype function. The content of the input XML instance is passed via the SAX2 interface.<?/en?></td>
    <td><?ja?>データ型のサポートはなく、常にString型として扱われます。文書はMSVを介さないでSAX2経由で読まれます。<?/ja?><?en?>The datatypes are not supported. All datatypes are interpreted as string type. The content of the input XML instance is passed via the SAX2 interface.<?/en?></td>
  </tr>
  
  <tr><td><?ja?>必要なライブラリ<?/ja?><?en?>Required Libraries<?/en?></td><td><?ja?>生成したコードの実行にはMSVのフルセットが必要です。<?/ja?><?en?>Whole of MSV is required to execute the generated code.<?/en?></td><td><?ja?>MSVのうちデータタイプライブラリ(xsdlib.jar)のみが必要です。<?/ja?><?en?>Only datatype library(xsdlib.jar) is required.<?/en?></td><td><?ja?>MSVは必要ありません。JAXP準拠のSAXパーサがあれば動作します。<?/ja?><?en?>Only JAXP-based SAX parser is required but not the MSV.<?/en?></td></tr>
  
  <tr><td><?ja?>文書のバリデーション能力<?/ja?><?en?>Validation Ability<?/en?></td><td><?ja?>文書はMSVがチェックするため、不正な入力を検出できます。<?/ja?><?en?>Invalid input is rejected since the MSV validates the input instance.<?/en?></td><td colspan="2"><?ja?>ある程度独自のチェックをしますが、入力によってはinvalidなXML文書を見逃すことがあります。例えば余計なアトリビュートが追加されていても検出はできません。<?/ja?><?en?>The generated code checks the content of input XML instance at some level, but it is not perfect. For example, the generated code outputs no warnings if unnecessary attributes exist.<?/en?></td></tr>
  <tr><td><?ja?>生成したコードの実行時にRELAX NG文法が必要か？<?/ja?><?en?>Is the grammar necessary on execution of generated code?<?/en?></td><td><?ja?>MSVを使うために必要です。<?/ja?><?en?>Yes, the MSV requires the grammar.<?/en?></td><td colspan="2"><?ja?>文法構造は生成したソースコードにとりこまれているので不要です。<?/ja?><?en?>No, the information of the grammar is embedded in the generated code.<?/en?></td></tr>
  <tr><td><?ja?>実行時に必要な<tt>relaxngcc.runtime</tt>パッケージ内のクラス<?/ja?><?en?>Required classes in relaxngcc.runtime package at runtime<?/en?></td><td><tt>NGCCTypedContentHandler</tt></td><td colspan="2"><tt>NGCCPlainHandler</tt></td></tr>
</table>
<p>
<?ja?>(*) MSV: Sun Multi-Schema XML Validator の略。<a href="http://www.sun.com/software/xml/developers/multischema/">http://www.sun.com/software/xml/developers/multischema/</a>からダウンロードできます。<?/ja?>
<?en?>(*) MSV: Sun Multi-Schema XML Validator. It is available from <a href="http://www.sun.com/software/xml/developers/multischema/">http://www.sun.com/software/xml/developers/multischema/</a>.<?/en?>
</p>
<p>
<?ja?>従って、入力文書がvalidであることがすでに分かっている場合や厳密なバリデーションが不要な場合は、SAXTypeやプレーンSAXを使うことで効率化が図れます。<?/ja?>
<?en?> Therefore, when the validity of the input is guaranteed or strict validation is not mandatory, the TypedSAX mode and the plain-SAX mode are more convenient than MSV mode.<?/en?>
</p>

<a name="usage">
<h2>4 <?ja?>生成したコードの使い方<?/ja?><?en?>Usage of the Generated Code<?/en?></h2>
<h3><?ja?>(このセクションはJAXPの知識を仮定しています。)<?/ja?><?en?>(This section assumes you are familiar to JAXP.)<?/en?></h3>
<p>
<?ja?>　RelaxNGCCが生成したコードをコンパイルしたり実行するには、上記の各動作モードに応じたライブラリが必要です。<?/ja?>
<?en?> To compile or execute the code generated by RelaxNGCC, some libraries are needed according to each operation mode. Please confirm the table in the previous section.<?/en?>
</p>
<p>
<?ja?>　生成したコードを呼び出すには、もとの文法の<tt>start</tt>エレメントに対応したクラスに付加される<tt>main()</tt>関数およびそこから呼ばれる<tt>getPreparedReader</tt>メソッドを参照してください。それぞれは以下のようになっています。<?/ja?>
<?en?> If you want to call the generated code, refer to the <tt>main()</tt> function and <tt>getPreparedReader</tt> method located at the class corresponding to the <tt>start</tt> element. Examples are following.<?/en?>
</p>
<p><?ja?>MSVモードでの例<?/ja?><?en?>Case of MSV mode<?/en?></p>
<pre>
public static XMLReader getPreparedReader(SAXParserFactory f, Grammar g)
 throws ParserConfigurationException, SAXException {
  XMLReader r = f.newSAXParser().getXMLReader();
  TypeDetecter v = new TypeDetecter(g);
  r.setContentHandler(v);
  v.setContentHandler(new sample1(v, null)); //sample1 is the class for the start element
  return r;
}
</pre>
<p><?ja?>TypedSAX, プレーンSAXでの例<?/ja?><?en?>Case of TypedSAX and plain-SAX mode<?/en?></p>
<pre>
public static XMLReader getPreparedReader(SAXParserFactory f)
 throws ParserConfigurationException, SAXException {
  XMLReader r = f.newSAXParser().getXMLReader();
  r.setContentHandler(new sample1(r, null)); //sample1 is the class for the start element
  return r;
}
</pre>
<p><?ja?>このgetPreparedReaderにSAXParserFactoryを渡すことで、XMLReaderが得られます。あとはこのXMLReaderに、読ませたいXMLドキュメントが入ったInputSourceをparseメソッドに渡すことでRelaxNGCCで生成されたコードの実行が開始されます。<?/ja?>
<?en?> You can get an XMLReader object by passing an XMLParserFactory to the getPreparedReader method. To run the code generated by RelaxNGCC, feed an InputSource of the input XML instance to the XMLReader.<?/en?>

<h3><?ja?>コンストラクタのカスタマイズ<?/ja?><?en?>How to customize constructor<?/en?></h2>
<p>
<?ja?>　RelaxNGCCで生成されたクラスのコンストラクタに独自の処理を入れるときは、RelaxNGCCの<tt>java-body</tt>エレメントに書いてください。このとき、次の基底クラスのコンストラクタを呼ぶようにしてください。<?/ja?>
<?en?>If you want to add your own code to the constructor of the class generated by RelaxNGCC, you should write it in the <tt>java-body</tt> element of RelaxNGCC. In this case, call following constructors of base class from your customized constructor.<?/en?>
</p>
<br>
MSV mode:<br>
<tt>protected NGCCTypedContentHandler(TypeDetecter reader)</tt><br>
<br>
PlainSAX <?ja?>または<?/ja?><?en?>or<?/en?> TypedSAX mode:<br>
<tt>protected NGCCPlainHandler(XMLReader reader)</tt><br>

<p>
<?ja?>引数のreaderは入力データが準備されていなければなりません。<?/ja?><?en?>Note that the argument <tt>reader</tt> must be prepared for the input XML.<?/en?>
</p>

<a name="typemap">
<h2>5 <?ja?>型の対応表<?/ja?><?en?>Type Correspondence Table<?/en?></h2>
<p>
<?ja?>　文法に書かれた型とJavaの型とのマッピングは次のようになります。これはRELAX NGのdataエレメントにRelaxNGCCのaliasアトリビュートをつけた場合に適用されます。現在、XML Schema Part2のデータ型のみがサポートされています。<?/ja?>
<?en?> This section describes the correspondences between the datatypes in XML and Java classes. The type of the object you named with alias attribute conforms on this table.<?/en?>
</p>
<table width="70%" border="1" align="center">
<tr><th><?ja?>XML Schema Part2の型<?/ja?><?en?>XML Schema Part2 Types<?/en?></th><th><?ja?>Javaの型<?/ja?><?en?>Java Types<?/en?></th></tr>
<tr><td><tt>boolean</tt></td><td><tt>java.lang.Boolean</tt></td></tr>
<tr><td><tt>byte</tt></td><td><tt>java.lang.Byte</tt></td></tr>
<tr><td><tt>short, unsignedByte</tt></td><td><tt>java.lang.Short</tt></td></tr>
<tr><td><tt>int, unsignedShort</tt></td><td><tt>java.lang.Integer</tt></td></tr>
<tr><td><tt>long, unsignedInt</tt></td><td><tt>java.lang.Long</tt></td></tr>
<tr><td><tt>unsignedLong</tt></td><td><tt>java.math.BigInteger</tt></td></tr>
<tr><td><tt>integer</tt></td><td rowspan="5"><tt>java.math.BigInteger</tt></td></tr>
<tr><td><tt>negativeInteger</tt></td></tr>
<tr><td><tt>positiveInteger</tt></td></tr>
<tr><td><tt>nonNegativeInteger</tt></td></tr>
<tr><td><tt>nonPositiveInteger</tt></td></tr>
<tr><td><tt>float</tt></td><td><tt>java.lang.Float</tt></td></tr>
<tr><td><tt>double</tt></td><td><tt>java.lang.Double</tt></td></tr>
<tr><td><tt>dateTime</tt></td><td rowspan="8"><tt>java.util.GregorianCalendar</tt></td></tr>
<tr><td><tt>date</tt></td></tr>
<tr><td><tt>time</tt></td></tr>
<tr><td><tt>gYear</tt></td></tr>
<tr><td><tt>gYearMonth</tt></td></tr>
<tr><td><tt>gMonth</tt></td></tr>
<tr><td><tt>gMonthDay</tt></td></tr>
<tr><td><tt>gDay</tt></td></tr>
<tr><td><tt>base64Binary</tt></td><td rowspan="2">byte[]</tt></td></tr>
<tr><td><tt>hexBinary</tt></td></tr>
<tr><td><?ja?>その他<?/ja?><?en?>Others<?/en?></td><td><tt>java.lang.String</tt></td></tr>
</table>
<p>
<?ja?>　この変換はMSV内のデータタイプライブラリに依存しています。MSVのドキュメントの、<tt>com.sun.msv.datatype.xsd</tt>パッケージの説明もあわせて参照してください。<?/ja?>
<?en?> These correspondences depend on the datatype library of MSV. See also the documentation of <tt>com.sun.msv.datatype.xsd</tt> package in MSV.<?/en?>
</p>

<a name="restrictions">
<h2>6 <?ja?>制約事項<?/ja?><?en?>Restrictions<?/en?></h2>
<p>
<?ja?>　RelaxNGCCでは、どんな文法も読み込めるわけではなく、先読み１個で分岐を判断できる文法だけを受け付けます。<?/ja?>
<?en?> RelaxNGCC can't process all kind of RELAX NG grammars. The given grammar must be deterministic at every branch by reading one token.<?/en?>
</p>
<pre>
 &lt;choice&gt;
   &lt;group&gt;
     &lt;element name="a"&gt;&lt;text/&gt;&lt;/element&gt;
     &lt;c:java&gt;System.out.println("a0");&lt;/c:java&gt;
     &lt;element name="x"&gt;&lt;text/&gt;&lt;/element&gt;
   &lt;/group&gt;
   &lt;group&gt;
     &lt;element name="a"&gt;&lt;text/&gt;&lt;/element&gt;
     &lt;c:java&gt;System.out.println("a1");&lt;/c:java&gt;
     &lt;element name="y"&gt;&lt;text/&gt;&lt;/element&gt;
   &lt;/group&gt;
 &lt;/choice&gt;
</pre>
<p>
<?ja?> このようなとき、最初に<tt>a</tt>エレメントをみただけではどちらのchoiceが正しいのかは判定できません。先読みをすれば<tt>x</tt>または<tt>y</tt>がきて判定可能になりますが、RelaxNGCCはこのような判定はできません。次のように書き換える必要があります。<?/ja?>
<?en?> In this sample, the correct branch of the <tt>choice</tt> element is not decidable by reading only the first <tt>a</tt> element. RelaxNGCC can't deal such case though the correct branch is decidable by reading more tokens. To avoid this, following modification is required.<?/en?>
</p>
<pre>
&lt;group&gt;
 &lt;element name="a"&gt;&lt;text/&gt;&lt;/element&gt;
 &lt;choice&gt;
   &lt;group&gt;
     &lt;element name="x"&gt;&lt;text/&gt;&lt;/element&gt;
     &lt;c:java&gt;System.out.println("a0");&lt;/c:java&gt;
   &lt;/group&gt;
   &lt;group&gt;
     &lt;element name="y"&gt;&lt;text/&gt;&lt;/element&gt;
     &lt;c:java&gt;System.out.println("a1");&lt;/c:java&gt;
   &lt;/group&gt;
 &lt;/choice&gt;
&lt;/group&gt;
</pre>
<p>
<?ja?>　文法がこの制約を満たさないとき、RelaxNGCCは警告メッセージを発します。特に文法があいまいな場合にはどう変形してもこの制約を逃れることができなくなるので注意が必要です。<?/ja?>
<?en?> If the given grammar does not conform to this restriction, RelaxNGCC outputs warning messages. Especially it is impossible to meet the condition if the grammar is ambiguous.<?/en?>
</p>
<p>
<?ja?>　情報科学の言葉で言えば、<tt>define</tt>や<tt>start</tt>ブロックを、SAXイベントを終端記号とした文脈自由文法として解釈したとき、それがLL(1)であるときに限りRelaxNGCCは取り扱えます。このあたりの議論はコンパイラの教科書に詳しく載っています。<?/ja?>
<?en?> In terms of information science, when we interpret the given RELAX NG grammar as a context free grammar by regarding every SAX events as terminal symbols, RelaxNGCC can treat only if the context free grammar is LL(1).<?/en?>
</p>

<a name="tbd">
<h2>7 <?ja?>未サポート機能<?/ja?><?en?>Unsupported Features<?/en?></h2>
<p>
<?ja?>　RELAX NGの仕様のうち、次の機能はまだサポートされていません。将来のバージョンで徐々に実装するつもりです。<?/ja?>
<?en?> Additionally, RelaxNGCC does not support yet following features of RELAX NG. They will be implemented in future version.<?/en?>
</p>
<ul>
<li><tt>externalRef</tt> <?ja?>エレメント<?/ja?><?en?>element<?/en?></li>
<li><tt>parentRef</tt> <?ja?>エレメント<?/ja?><?en?>element<?/en?></li>
<li><?ja?>name-classを使ったアトリビュート<?/ja?><?en?>attributes using name-classes<?/en?></li>
</ul>
<hr>
<div align="right"><?ja?><a href="#top">マニュアルのトップ</a>&nbsp;&nbsp;<a href="index_ja.htm">RelaxNGCCトップ</a><?/ja?><?en?><a href="#top">Manual Top</a>&nbsp;&nbsp;<a href="index_en.htm">RelaxNGCC Top</a><?/en?></div>

</body>
</html>