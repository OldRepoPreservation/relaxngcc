<html>
<head>
	<title>RelaxNGCC manual</title>
	<link rel="stylesheet" href="ngcc.css"/>
	
</head>
<body>
<a name="top">
<h1>RelaxNGCC Manual</h1>
<div align="right">Last update May 3, 2002</div>
<div>Contents</div>
<ul>
<li><a href="#scope">Scopes</a></li>
<li><a href="#markup">Mark-ups</a></li>
<li><a href="#modes">Operation Modes</a></li>
<li><a href="#usage">Usage of the Generated Code</a></li>
<li><a href="#typemap">Type Correspondence Table</a></li>
<li><a href="#restrictions">Restrictions</a></li>
<li><a href="#tbd">Unsupported Features</a></li>
</ul>

<a name="scope">
<h2>1 Scopes</h2>
<p>Scopes are important concept for RelaxNGCC. It generates scopes along following rules and outputs a Java class for each scope.</p>
<ul>
<li>Each <tt>define</tt> block or <tt>start</tt> block corresponds to a scope.</li>
<li>However, elements with <tt>class</tt> attributes (described later) are separated into independent scopes.</li>
<li>Additionally, <tt>define</tt> elements with <tt>inline</tt> attributes are expanded into other scopes.</li>
</ul>
<p>For example, RelaxNGCC produces 3 scopes from the next grammar since it contains 1 <tt>start</tt> element and 2 <tt>define</tt> elements.
<pre>
&lt;grammar xmlns="http://relaxng.org/ns/structure/1.0"&gt;
  &lt;start&gt;
    ...
  &lt;/start&gt;
  &lt;define name="A"&gt;
    ...
  &lt;/define&gt;
  &lt;define name="B"&gt;
    ...
  &lt;/define&gt;
&lt;/grammar&gt;
</pre>

<a name="markup">
<h2>2 Mark-ups</h2>
<p>
 The extended mark-ups peculiar to RelaxNGCC have the namespace-URI <br><br><tt style="font-weight:bold;">http://www.xml.gr.jp/xmlns/relaxngcc</tt>, while the namespace is represented by prefix "<tt>c</tt>" in this manual.<br><br>They consist of following 3 kinds elements and 5 kinds attributes.</p>

<h3>2.1 <tt>alias</tt> attribute</h3>
<p>
 We can use this attribute to refer to data from the user-defined code in <tt>java</tt> elements. The <tt>alias</tt> attribute is applicable to the <tt>data</tt>, <tt>text</tt>, <tt>ref</tt>, <tt>value</tt>, <tt>list</tt> elements of RELAX NG.
</p>
<pre>
&lt;data type="nonNegativeInteger" <span class="emph-code">c:alias="count"</span>/&gt;
</pre>
<p>
 The type of the Java object named by the <tt>alias</tt> attribute is fixed by the following table.
</p>
<table border="1">
<tr><th>RELAX NG element</th><th>type</th></tr>
<tr><td><tt>data</tt></td><td>String (<a href="#modes">plain sax mode</a>), otherwise <br>depends on datatype(other mode)(*1)</td></tr>
<tr><td><tt>text</tt></td><td>String</td></tr>
<tr><td><tt>ref</tt></td><td>The class generated by RelaxNGCC for the destination scope of the reference.</td></tr>
<tr><td><tt>value</tt></td><td>String</td></tr>
<tr><td><tt>list</tt></td><td>String (*2)</td></tr>
</table>
<p>
 (*1) The type depends on <tt>type</tt> attribute of the <tt>data</tt> element. The <a href="#typemap">table</a> in this document describes the correspondence. Although RELAX NG has the design that can use datatypes other than XML Schema Part2, RelaxNGCC supports only XML Schema Part 2.<br> (*2) If you place the <tt>alias</tt> attribute with a <tt>list</tt> element, the entire of the data that matches the <tt>list</tt> element is dealed as a string. RelaxNGCC does not split the data into whitespace-separated sequence of tokens.
</p>
<p> Since the code generated by RelaxNGCC conforms to the SAX interface, the names declared by <code>alias</code> attributes become data members of the generated class. Therefore identical names must not exist in a scope. If the programmer break this rule, the generated code will fail to compile.

<h3>2.2 <tt>java</tt> element</h3>
<p>

 You can write a code fragment of Java in the <tt>java</tt> element. In this fragment, you can refer to the data of the XML instance by variables defined with the <tt>alias</tt> attribite. The content of <tt>java</tt> element is executed during the parse of the input. <br>
<pre>
&lt;element name="name"&gt;
  &lt;text <span class="emph-code">c:alias="name"</span>/&gt;
  <span class="emph-code">&lt;c:java&gt;System.out.println(name);&lt;/c:java&gt;</span>
&lt;/element&gt;
</pre>
<p>

 Since the code generated by RelaxNGCC conforms to the SAX2 interface, only <tt>SAXException</tt> or its derivative exceptions can be thrown in the <tt>java</tt> element.
</p>
<p>

 The <tt>java</tt> element can appear any location of the scope. A detailed document about the location of <tt>java</tt> element and the execution condition will be available later.
</p>
<p>

 Note that the reason for using "<tt>java</tt>" for the element name is that RelaxNGCC may support other program languages (for example, C#) besides the future.
</p>

<h3>2.3 <tt>java-body</tt> element</h3>
<p>

 You can write methods and data members of generated classes using <tt>java-body</tt> element. Since RelaxNGCC copies the content of the <tt>java-body</tt> into the Java code, you can refer to the methods and the data members from your code in all <tt>java</tt> elements.<br>
<pre>
&lt;define name="x"&gt;
  <span class="emph-code">&lt;c:java-body&gt;
  private void echo(String msg)
  { System.out.println(msg); }
  &lt;/c:java-body&gt;</span>
  ...
&lt;/define&gt;
</pre>
<p>

 For example, the <tt>echo</tt> method is available from all the <tt>java</tt> elements in the <tt>define</tt> block. 
</p>
<p>

 A <tt>java-body</tt> element is allowed only following locations:
<dl>
<dt>a. under <tt>grammar</tt> element</dt>
<dd>The content of <tt>java-body</tt> is inserted into all classes generated by RelaxNGCC.</dd>
<dt>b. under <tt>start</tt> or <tt>define</tt> element</dt>
<dd>The content of <tt>java-body</tt> is inserted into only the class corresponding to the <tt>start</tt> or <tt>define</tt> element.</dd>
</dl>
<h3>2.4 <tt>java-import</tt> element</h3>
<p>

 Unlike <tt>java-body</tt>, the content of <tt>java-import</tt> element is copied outside of the definition of the class. In common case, you would write import declarations in the <tt>java-import</tt> element. The allowed location of <tt>java-import</tt> is same as <tt>java-body</tt>. 
</p>
<pre>
<span class="emph-code">&lt;c:java-import&gt;
import java.util.Set;
import java.util.Iterator;
&lt;/c:java-import&gt;</span>
</pre>
<h3>2.5 <tt>class</tt> attribute</h3>
<p>

 The <tt>class</tt> attribute appears at a <tt>start</tt> element or a <tt>define</tt> element, and defines the name of generated Java class. The value of <tt>class</tt> attribute must be valid as a name of a Java class. If it is omitted, RelaxNGCC gives a suitable name for the class.
<pre>
&lt;start <span class="emph-code">c:class="Root"</span>&gt;
...
&lt;/start&gt;
</pre>
<p>

 Additionally, the <tt>class</tt> attribute can appear at some RELAX NG elements such as <tt>element</tt> element or <tt>oneOrMore</tt> element. In this case, the corresponding block enclosed by the RELAX NG element is chopped off into a Java class. Since the class is located in the inner-class of the class for parent <tt>define</tt>/<tt>start</tt> element, you can access data members of the parent class including data named via <tt>alias</tt> attribute.
<pre>
&lt;define name="parent"&gt;
  &lt;c:body&gt;
  Set _Items = new HashSet();
  &lt;/c:body&gt;
  &lt;zeroOrMore <span class="emph-code">c:class="Item" c:alias="item"</span>&gt;
    &lt;data type="string" c:alias="_uri"/&gt;
    &lt;data type="string" c:alias="_location"/&gt;
    &lt;c:java&gt;
     _Items.add(this);
    &lt;/c:java&gt;
  &lt;/zeroOrMore&gt;
&lt;/define&gt;
</pre>

<p>Note that the <tt>class</tt> attribute is ignored when the <tt>define</tt> element has <tt>combine</tt> attribute because the <tt>define</tt> block is merged into other block.</p>

<h3>2.6 <tt>inline</tt> attribute</h3>
<p>

 The <tt>inline</tt> attribute can appear in <tt>define</tt> elements and indicates that the scope is expanded into other scopes refering to it. <span style="text-decoration:underline">Especially scopes that consists of only text elements must be expanded</span>. This is a restriction of RelaxNGCC.
</p>
<pre>
&lt;define name="block" <span class="emph-code">c:inline="true"</span>&gt;
...
</pre>

<h3>2.7 <tt>package</tt> attribute</h3>
<p>

 The <tt>package</tt> attribute can appear on the top <tt>grammar</tt> element of RELAX NG and defines the Java package name of generated classes.
</p>
<pre>
&lt;grammar ... <span class="emph-code">c:package="com.example.project1"</span>&gt;
...
</pre>
<h3>2.8 <tt>access</tt> attribute</h3>
<p>

 The <tt>access</tt> attribute declares the access modifiers (i.e. "public final") for generated Java class. This attribute can appear in <tt>define</tt> elements, <tt>start</tt> elements, and any elements with <tt>class</tt> attribute.
</p>
<pre>
&lt;start <span class="emph-code">c:class="sample1"</span> <span class="emph-code">c:access="public final"</span>&gt;
...
&lt;/start&gt;
</pre>

<a name="modes">
<h2>3 Operation Modes of RelaxNGCC</h2>
<p>

 In RelaxNGCC, you can choose the style of generated Java source code from three kinds. The features of the three styles are following.
</p>
<table border="1" width="100%">
  
  <tr><th width="25%">&nbsp;</th><th width="25%">MSV mode</th><th width="25%">Typed SAX mode</th><th width="25%">plain SAX mode</th></tr>
  
  <tr><td>RelaxNGCC options</td><td><tt>--msv</tt></td><td><tt>--typedsax</tt></td><td><tt>(default)</tt></td></tr>
  
  <tr>
    <td>Description</td>
    <td>The input XML instance is checked by the RELAX NG implementation of MSV at first, and the generated code receives it via <tt>TypedContentHandler</tt> interface later.</td>
    <td>The MSV is used for only datatype function. The content of the input XML instance is passed via the SAX2 interface.</td>
    <td>The datatypes are not supported. All datatypes are interpreted as string type. The content of the input XML instance is passed via the SAX2 interface.</td>
  </tr>
  
  <tr><td>Required Libraries</td><td>Whole of MSV is required to execute the generated code.</td><td>Only datatype library(xsdlib.jar) is required.</td><td>Only JAXP-based SAX parser is required but not the MSV.</td></tr>
  
  <tr><td>Validation Ability</td><td>Invalid input is rejected since the MSV validates the input instance.</td><td colspan="2">The generated code checks the content of input XML instance at some level, but it is not perfect. For example, the generated code outputs no warnings if unnecessary attributes exist.</td></tr>
  <tr><td>Is the grammar necessary on execution of generated code?</td><td>Yes, the MSV requires the grammar.</td><td colspan="2">No, the information of the grammar is embedded in the generated code.</td></tr>
  <tr><td>Required classes in relaxngcc.runtime package at runtime</td><td><tt>NGCCTypedContentHandler</tt></td><td colspan="2"><tt>NGCCPlainHandler</tt></td></tr>
</table>
<p>

(*) MSV: Sun Multi-Schema XML Validator. It is available from <a href="http://www.sun.com/software/xml/developers/multischema/">http://www.sun.com/software/xml/developers/multischema/</a>.
</p>
<p>

 Therefore, when the validity of the input is guaranteed or strict validation is not mandatory, the TypedSAX mode and the plain-SAX mode are more convenient than MSV mode.
</p>

<a name="usage">
<h2>4 Usage of the Generated Code</h2>
<h3>(This section assumes you are familiar to JAXP.)</h3>
<p>

 To compile or execute the code generated by RelaxNGCC, some libraries are needed according to each operation mode. Please confirm the table in the previous section.
</p>
<p>

 If you want to call the generated code, refer to the <tt>main()</tt> function and <tt>getPreparedReader</tt> method located at the class corresponding to the <tt>start</tt> element. Examples are following.
</p>
<p>Case of MSV mode</p>
<pre>
public static XMLReader getPreparedReader(SAXParserFactory f, Grammar g)
 throws ParserConfigurationException, SAXException {
  XMLReader r = f.newSAXParser().getXMLReader();
  TypeDetecter v = new TypeDetecter(g);
  r.setContentHandler(v);
  v.setContentHandler(new sample1(v, null)); //sample1 is the class for the start element
  return r;
}
</pre>
<p>Case of TypedSAX and plain-SAX mode</p>
<pre>
public static XMLReader getPreparedReader(SAXParserFactory f)
 throws ParserConfigurationException, SAXException {
  XMLReader r = f.newSAXParser().getXMLReader();
  r.setContentHandler(new sample1(r, null)); //sample1 is the class for the start element
  return r;
}
</pre>
<p>
 You can get an XMLReader object by passing an XMLParserFactory to the getPreparedReader method. To run the code generated by RelaxNGCC, feed an InputSource of the input XML instance to the XMLReader.

<h3>How to customize constructor</h2>
<p>

If you want to add your own code to the constructor of the class generated by RelaxNGCC, you should write it in the <tt>java-body</tt> element of RelaxNGCC. In this case, call following constructors of base class from your customized constructor.
</p>
<br>
MSV mode:<br>
<tt>protected NGCCTypedContentHandler(TypeDetecter reader)</tt><br>
<br>
PlainSAX or TypedSAX mode:<br>
<tt>protected NGCCPlainHandler(XMLReader reader)</tt><br>

<p>
Note that the argument <tt>reader</tt> must be prepared for the input XML.
</p>

<a name="typemap">
<h2>5 Type Correspondence Table</h2>
<p>

 This section describes the correspondences between the datatypes in XML and Java classes. The type of the object you named with alias attribute conforms on this table.
</p>
<table width="70%" border="1" align="center">
<tr><th>XML Schema Part2 Types</th><th>Java Types</th></tr>
<tr><td><tt>boolean</tt></td><td><tt>java.lang.Boolean</tt></td></tr>
<tr><td><tt>byte</tt></td><td><tt>java.lang.Byte</tt></td></tr>
<tr><td><tt>short, unsignedByte</tt></td><td><tt>java.lang.Short</tt></td></tr>
<tr><td><tt>int, unsignedShort</tt></td><td><tt>java.lang.Integer</tt></td></tr>
<tr><td><tt>long, unsignedInt</tt></td><td><tt>java.lang.Long</tt></td></tr>
<tr><td><tt>unsignedLong</tt></td><td><tt>java.math.BigInteger</tt></td></tr>
<tr><td><tt>integer</tt></td><td rowspan="5"><tt>java.math.BigInteger</tt></td></tr>
<tr><td><tt>negativeInteger</tt></td></tr>
<tr><td><tt>positiveInteger</tt></td></tr>
<tr><td><tt>nonNegativeInteger</tt></td></tr>
<tr><td><tt>nonPositiveInteger</tt></td></tr>
<tr><td><tt>float</tt></td><td><tt>java.lang.Float</tt></td></tr>
<tr><td><tt>double</tt></td><td><tt>java.lang.Double</tt></td></tr>
<tr><td><tt>dateTime</tt></td><td rowspan="8"><tt>java.util.GregorianCalendar</tt></td></tr>
<tr><td><tt>date</tt></td></tr>
<tr><td><tt>time</tt></td></tr>
<tr><td><tt>gYear</tt></td></tr>
<tr><td><tt>gYearMonth</tt></td></tr>
<tr><td><tt>gMonth</tt></td></tr>
<tr><td><tt>gMonthDay</tt></td></tr>
<tr><td><tt>gDay</tt></td></tr>
<tr><td><tt>base64Binary</tt></td><td rowspan="2">byte[]</tt></td></tr>
<tr><td><tt>hexBinary</tt></td></tr>
<tr><td>Others</td><td><tt>java.lang.String</tt></td></tr>
</table>
<p>

 These correspondences depend on the datatype library of MSV. See also the documentation of <tt>com.sun.msv.datatype.xsd</tt> package in MSV.
</p>

<a name="restrictions">
<h2>6 Restrictions</h2>
<p>

 RelaxNGCC can't process all kind of RELAX NG grammars. The given grammar must be deterministic at every branch by reading one token.
</p>
<pre>
 &lt;choice&gt;
   &lt;group&gt;
     &lt;element name="a"&gt;&lt;text/&gt;&lt;/element&gt;
     &lt;c:java&gt;System.out.println("a0");&lt;/c:java&gt;
     &lt;element name="x"&gt;&lt;text/&gt;&lt;/element&gt;
   &lt;/group&gt;
   &lt;group&gt;
     &lt;element name="a"&gt;&lt;text/&gt;&lt;/element&gt;
     &lt;c:java&gt;System.out.println("a1");&lt;/c:java&gt;
     &lt;element name="y"&gt;&lt;text/&gt;&lt;/element&gt;
   &lt;/group&gt;
 &lt;/choice&gt;
</pre>
<p>

 In this sample, the correct branch of the <tt>choice</tt> element is not decidable by reading only the first <tt>a</tt> element. RelaxNGCC can't deal such case though the correct branch is decidable by reading more tokens. To avoid this, following modification is required.
</p>
<pre>
&lt;group&gt;
 &lt;element name="a"&gt;&lt;text/&gt;&lt;/element&gt;
 &lt;choice&gt;
   &lt;group&gt;
     &lt;element name="x"&gt;&lt;text/&gt;&lt;/element&gt;
     &lt;c:java&gt;System.out.println("a0");&lt;/c:java&gt;
   &lt;/group&gt;
   &lt;group&gt;
     &lt;element name="y"&gt;&lt;text/&gt;&lt;/element&gt;
     &lt;c:java&gt;System.out.println("a1");&lt;/c:java&gt;
   &lt;/group&gt;
 &lt;/choice&gt;
&lt;/group&gt;
</pre>
<p>

 If the given grammar does not conform to this restriction, RelaxNGCC outputs warning messages. Especially it is impossible to meet the condition if the grammar is ambiguous.
</p>
<p>

 In terms of information science, when we interpret the given RELAX NG grammar as a context free grammar by regarding every SAX events as terminal symbols, RelaxNGCC can treat only if the context free grammar is LL(1).
</p>

<a name="tbd">
<h2>7 Unsupported Features</h2>
<p>

 Additionally, RelaxNGCC does not support yet following features of RELAX NG. They will be implemented in future version.
</p>
<ul>
<li><tt>externalRef</tt> element</li>
<li><tt>parentRef</tt> element</li>
<li>attributes using name-classes</li>
</ul>
<hr>
<div align="right"><a href="#top">Manual Top</a>&nbsp;&nbsp;<a href="index_en.htm">RelaxNGCC Top</a></div>

</body>
</html>