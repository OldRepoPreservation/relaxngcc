<html>
<head>
	<title>RelaxNGCC Algorithm</title>
	<link rel="stylesheet" href="ngcc.css">
	
</head>
<body>
<h1>RelaxNGCC Algorithm</h1>
<p> This page describes how RelaxNGCC generates Java source code. It also assumes you are familiar with automaton.</p>
<p>This explanation is not a detailed algorithm but an outline. If you hava any question about internal behavior of RelaxNGCC, please analyse source code or send me via mail. </p>
<h2>Step 1　Dividing into scopes</h2>
<p>

 A scope is a block that consists of elements, attributes, and data defined by a <tt>start</tt> or a <tt>define</tt> element of a RelaxNG grammar. A grammar is devided into one or more scopes by processing <tt>include</tt> elements and <tt>combine</tt> attributes.
</p>
<p> RelaxNGCC generates an automaton and a Java class per a scope.</p>
<h2>Step 2　Constructing automaton</h2>
<p>Next step is generating an automaton about each scope. In this automaton, there are following 5 kinds of alphabet. </p>
<ul>
<li>startElement</li>
<li>endElement</li>
<li>attribute</li>
<li>ref</li>
<li>value</li>
</ul>
<p>

 The kinds "startElement", "endElement", and "attribute" have properties about namespace-URI and localname. We call the pair of the namespace-URI and the localname "name" simply. Additionally, we introduce an expression "startElement[x]" for a startElement type alphabet whose name is "x".
</p>
<p>

 A "ref" type alphabet is identified by a scope it refers to. We introduce an expression ref[S] for a ref type alphabet that refers to a scope "S" and another expression scope(r) for a scope that is referred to by a ref type alphabet "r".
</p>
<p>

 On the other hand, the value type alphabet has a datatype property. The data type is detailed in W3C XML Schema Part2, and RelaxNGCC uses datatype.</p>
<p> For example, following scope</p>
<pre>
&lt;define name="foo"&gt;
  &lt;element name="x"&gt;
    &lt;oneOrMore&gt;
      &lt;element name="y"&gt;&lt;text/&gt;&lt;/element&gt;
    &lt;/oneOrMore&gt;
    &lt;attribute name="a"&gt;&lt;text/&gt;&lt;/attribute&gt;
  &lt;/element&gt;
&lt;/define&gt;
</pre>
<p>generates following automaton</p>
<pre>
  startE[x]   startE[y]   value[string]  endE[y]     attribute[a]   endE[x]
S --------&gt; O --------&gt; O -----------&gt; O --------&gt; O ------------&gt; O ------&gt; F
                        &and;                         |
                        |__________________________|
                               startE[y]
</pre>
<p> where S is the initial state and F is the final state.</p>
<p>Here is another example.</p>
<pre>
&lt;define name="foo"&gt;
  &lt;zeroOrMore&gt;
    &lt;element name="y"&gt;&lt;data type="int"/&gt;&lt;/element&gt;
  &lt;/zeroOrMore&gt;
  &lt;choice&gt;
    &lt;ref name="a"/&gt;&lt;
    &lt;ref name="b"/&gt;&lt;
  &lt;/choice&gt;
&lt;/define&gt;
</pre>
<pre>
                     startE[y]
                ------------------------
                |                      |
      startE[y] v value[int]   endE[y] |
|-- S --------&gt; O ---------&gt; O ------&gt; O --
|   |                                  |  |
|   |   ref[a]           ref[a]        |  |
|   ------------&gt; F &lt;-------------------  |
----------------&gt; F &lt;----------------------
     ref[b]              ref[b]

</pre>
<p>

 Note that there are no alphabets that represent the end of attribute.<br> We introduce a expression tr(x,a,y) for a transition from a state <tt>x</tt> to <tt>y</tt> with an alphabet <tt>a</tt>.
</p>
<h2>Step 3　Adding actions defined by user</h2>
<p>

 The result source code generated by RelaxNGCC must execute the code fragment embedded by the user at appropriate moment. This moment is associated with a transition of the automaton constructed in Step 2. 
</p>
<pre>
&lt;define name="foo"&gt;
  &lt;element name="x"&gt;
    &lt;oneOrMore&gt;
      &lt;element name="y"&gt;&lt;text c:alias="t"/&gt;<span class="emph-code">&lt;c:java&gt;System.out.println(t);&lt;/c:java&gt;</span>&lt;/element&gt;
    &lt;/oneOrMore&gt;
    &lt;attribute name="a"&gt;&lt;text/&gt;&lt;/attribute&gt;
  &lt;/element&gt;
&lt;/define&gt;
</pre>

<pre>
  start "x"   start "y"   <span class="emph-code">value[string]</span>  end "y"     attribute "a"   end "x"
S --------&gt; O --------&gt; O <span class="emph-code">-----------&gt;</span> O --------&gt; O ------------&gt; O ------&gt; F
                        ^                          |
                        |__________________________|
                               start "y"
</pre>
<p>

In the example above, the code fragment <tt>System.out.println(t);</tt> is executed at the emphasized transition. Thus, RelaxNGCC associates the code fragment embedded by user with transitions of automaton. 
</p>

<h2>Step 4　FIRST and FOLLOW</h2>
<p>For each scope S, we define a set of alphabets FIRST(S) as ollows.</p>
<p style="border-width:1px; border-style:solid;">
a &isin; FIRST(S) &hArr; <br>
&nbsp;&nbsp;A Transition (initial(S),a,j) exists, where <tt> a </tt> is not "ref" type. Or, <br>
&nbsp;&nbsp;<tt>a</tt> &isin; FIRST(S'), and a transition (initial(S),r,j) exists where r is a ref type alphabet and scope(r)=S'.
</p>
<p>Note that initial(S) is the initial state of the automaton constructed from S.</p>
<p>

 Next, we define a set of alphabet FOLLOW(S) as follows.
</p>
<p style="border-width:1px; border-style:solid;">
a &isin; FOLLOW(S) &hArr; If there is a ref type alphabet <tt>r</tt> in a scope S' where scope(r)=S, two transition tr(x,r,y) and tr(y,a,z) must exist in the scope S.</p>
<p>Frankly speaking, FIRST alphabet notifies start of an scope and FOLLOW alphabet notifies end of an scope. I borrowed the concept of FIRST and FOLLOW from the compiler theory about LR context free grammar. RelaxNGCC computes FIRST and FOLLOW for all scopes.</p>
<h2>Step 5　Determinacy check</h2>
<p>
As for RelaxNGCC, the automaton constructed by each scope must be deterministic. It is possible theoretically to avoid this restriction by looking ahead more tokens, but it is hard to implement.
</p>
<p>

 An automaton generated by a scope X is non-deterministic if a state O that satisfies any of following conditions exists.
</p>
<ol>
<li>Multiple transition from O with an identical alphabet exist.</li>
<li>A transition from O with a <tt>ref</tt> type alphabet <tt>r</tt> exists, and another transition from O with an alphabet in FIRST(scope(r)).</li>
<li>Two ref type transition from O with <tt>ref</tt> type alphabet r and r' exist, and the intersection of FIRST(scope(r)) and FIRST(scope(r')) is not empty.</li>
<li>O is an accept state and a transition from O with an alphabet in FOLLOW(X) exists. This condition is not irrelevant to the determinacy of the automaton, but violation of this condition exceeds the ability of RelaxNGCC since it causes ambifuousity of end of scope.</li>
</ol>
<p>Here is an example of violating the second condition. At the head of <tt>choice</tt> a transition with <tt>startElement[x]</tt> is allowd, though <tt>startElement[x]</tt> is contained the FIRST of the scope with name <tt>a</tt>. </p>
<pre>
&lt;define name="a"&gt;
  &lt;element name="x"&gt;...&lt;/element&gt;
&lt;/define&gt;
&lt;start&gt;
  &lt;choice&gt;
    &lt;element name="x"&gt;...&lt;/element&gt;
    &lt;ref name="a"/&gt;
  &lt;/choice&gt;
&lt;/start&gt;
</pre>
<p>Here is an example of violating the fourth condition. A transition with <tt>startElement[x]</tt> is allowed from the accept state of the scope <tt>a</tt>, however the line (*) indicates the FOLLOW of the scope contains <tt>startElement[x]</tt>.</p>
<pre>
&lt;define name="a"&gt;
  &lt;oneOrMore&gt;&lt;element name="x"&gt;...&lt;/element&gt;&lt;/oneOrMore&gt;
&lt;/define&gt;
&lt;start&gt;
  &lt;ref name="a"/&gt;
  &lt;element name="x"&gt;...&lt;/element&gt; (*)
&lt;/start&gt;
</pre>
<p> If the determinacy check is failed, RelaxNGCC outputs warning message and quits.</p>
<h2>Step 6　Generating code</h2>
<p>

 Then RelaxNGCC generates source code. The trigger of transition is SAX events such as <tt>startElement</tt>, <tt>endElement</tt>, and so on. But a special rule is needed since attributes are notified only at <tt>startElement</tt>.
</p>
<ul>
<li>When the code receives a set of attributes at <tt>startElement</tt>, the code pushes it into a stack.</li>
<li>At <tt>endElement</tt> the code pops the attribute set from the stack.</li>
<li>On every transition, the code checks if the destination state of the transition satisfies all of following conditions:
<ul>
<li>A transition with attribute type alphabet <tt>x</tt> is allowd.</li>
<li>The attribute set located on the top of the stack contains an attribute whose name is the name of <tt>x</tt>.</li>
</ul>
If so, the transitions with <tt>x</tt> and the text of the value of <tt>x</tt> are processed.
</ul>

<p> Additionally, here is rules of the start and end of scope.</p>
<ul>
<li>If the current state O has a transition with ref type alphabet r and the code receives an alphabet <tt>x</tt> contained in FIRST(scope(r)),
<ul>
<li>preserves the destination state P,</li>
<li>sets the current state the initial state of the automaton of <tt>scope(r)</tt>,</li>
<li> and the transition with <tt>x</tt> is processed.</li>
</ul>
<li>If the current state O is accept state and the code receives an alphabet <tt>x</tt> contained in FOLLOW(scope(O)),
<ul>
<li>sets the current state the preserved state P,</li>
<li> and the transition with <tt>x</tt> is processed.</li>
</ul>
</ul>
<p>In terms of SAX, the <tt>ContentHandler</tt> is replaced at the start of a scope, and it is recovered at the end of the scope.</p>
<hr>
<p align="right"><a href="index_en.htm">RelaxNGCC home</a></p>
</body>
</html>