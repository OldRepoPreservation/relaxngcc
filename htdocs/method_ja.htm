<html>
<head>
	<title>RelaxNGCC 動作原理</title>
	<link rel="stylesheet" href="ngcc.css">
	<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=shift_jis">
</head>
<body>
<h1>RelaxNGCC 動作原理</h1>
<p>　ここではRelaxNGCCがどうやって動くかの説明をします。この説明を理解するには、オートマトンについての基礎知識が必要です。</p>
<p>　このページですべての仕様を説明しているわけではないですし、そこまでのドキュメントを書くのも大変なのでややさぼり気味です。深く知りたい方は疑問点はソースコードを調べたりメーリングリスト等で質問してください。</p>
<h2>Step 1　スコープへの切り分け</h2>
<p>
　まず、RelaxNG grammarにおいて、<tt>start</tt>または<tt>define</tt>エレメントで定義される要素と属性のブロックをスコープと定義します。<tt>include</tt>エレメントと、<tt>start</tt>および<tt>define</tt>の<tt>combine</tt>属性を処理することにより、grammar全体は１個以上のスコープに分解されます。

</p>
<p>　RelaxNGCCは、スコープ１個について１個の文字列オートマトンと１個のJavaクラスを生成します。</p>
<h2>Step 2　オートマトンの作成</h2>
<p>　次にそれぞれのスコープについて文字列オートマトンを作成します。このオートマトンでは、アルファベットの種類は</p>
<ul>
<li>startElement</li>
<li>endElement</li>
<li>attribute</li>
<li>ref</li>
<li>value</li>
</ul>
<p>
の５つがあります。このうち、startElement, endElement, attributeの３種類はnamespace-URIとlocalname属性を持っています。以降では、namespace-URIとlocalnameの組を単に「名前」と呼び、startElement[x]で名前 x のstartElementタイプのアルファベットを表現します。


</p>
<p>
　refはそれが参照するスコープで区別がなされます。スコープ S を参照するrefタイプのアルファベットをref[S]で表現します。また、refタイプのアルファベット r に対し、それが参照するスコープを scope(r) と表記します。

</p>
<p>
　valueは、アルファベットの属性として型があります。型はMulti-Schema Validatorに組み込まれたW3C XML Schema Part2のデータ型です。
</p>
<p>　たとえば、次のスコープ</p>
<pre>
&lt;define name="foo"&gt;
  &lt;element name="x"&gt;
    &lt;oneOrMore&gt;
      &lt;element name="y"&gt;&lt;text/&gt;&lt;/element&gt;
    &lt;/oneOrMore&gt;
    &lt;attribute name="a"&gt;&lt;text/&gt;&lt;/attribute&gt;
  &lt;/element&gt;
&lt;/define&gt;
</pre>
<p>に対しては、次のオートマトン</p>
<pre>
  startE[x]   startE[y]   value[string]  endE[y]     attribute[a]   endE[x]
S --------&gt; O --------&gt; O -----------&gt; O --------&gt; O ------------&gt; O ------&gt; F
                        &and;                         |
                        |__________________________|
                               startE[y]
</pre>
<p>が作成されます。ここでSは初期状態、Fは受理状態です。</p>
<p>　もう一つ例を出します。</p>
<pre>
&lt;define name="foo"&gt;
  &lt;zeroOrMore&gt;
    &lt;element name="y"&gt;&lt;data type="int"/&gt;&lt;/element&gt;
  &lt;/zeroOrMore&gt;
  &lt;choice&gt;
    &lt;ref name="a"/&gt;&lt;
    &lt;ref name="b"/&gt;&lt;
  &lt;/choice&gt;
&lt;/define&gt;
</pre>
<pre>
                     startE[y]
                ------------------------
                |                      |
      startE[y] v value[int]   endE[y] |
|-- S --------&gt; O ---------&gt; O ------&gt; O --
|   |                                  |  |
|   |   ref[a]           ref[a]        |  |
|   ------------&gt; F &lt;-------------------  |
----------------&gt; F &lt;----------------------
     ref[b]              ref[b]

</pre>
<p>
　なお、アトリビュートの終端を示すアルファベットは存在しません。このことは後でオートマトンの遷移手順で説明します。また、状態 x からアルファベット a で状態 y へ遷移する遷移規則をtr(x,a,y)と表現します。

</p>
<h2>Step 3　ユーザアクションの付加</h2>
<p>
　RelaxNGCCではユーザの書いたコード断片を実行するわけですが、どのタイミングで実行するかはオートマトンの遷移規則の実行時です。例えば上記の例で、

</p>
<pre>
&lt;define name="foo"&gt;
  &lt;element name="x"&gt;
    &lt;oneOrMore&gt;
      &lt;element name="y"&gt;&lt;text c:alias="t"/&gt;<span class="emph-code">&lt;c:java&gt;System.out.println(t);&lt;/c:java&gt;</span>&lt;/element&gt;
    &lt;/oneOrMore&gt;
    &lt;attribute name="a"&gt;&lt;text/&gt;&lt;/attribute&gt;
  &lt;/element&gt;
&lt;/define&gt;
</pre>
となっていれば、
<pre>
  start "x"   start "y"   <span class="emph-code">value[string]</span>  end "y"     attribute "a"   end "x"
S --------&gt; O --------&gt; O <span class="emph-code">-----------&gt;</span> O --------&gt; O ------------&gt; O ------&gt; F
                        ^                          |
                        |__________________________|
                               start "y"
</pre>
<p>
この強調した遷移規則を実行するときにユーザの書いた<tt>System.out.println(t);</tt>を実行すればよいことになります。このようにして、ユーザアクションつきオートマトンを作成します。

</p>

<h2>Step 4　FIRSTとFOLLOW</h2>
<p>　あるスコープ S について、アルファベットの集合 FIRST(S) を次のように定義します。</p>
<p style="border-width:1px; border-style:solid;">
a &isin; FIRST(S) &hArr; <br>
&nbsp;&nbsp;Sの作るオートマトンの初期状態からrefタイプでないアルファベット a で遷移可能である。または<br>
&nbsp;&nbsp;a &isin; FIRST(S')かつ、Sの作るオートマトンの初期状態からscope(r)=S'なるrefタイプのアルファベットで遷移可能である。
</p>
<p></p>
<p>
　次に FOLLOW(S) を次のように定義します。

</p>
<p style="border-width:1px; border-style:solid;">
a &isin; FOLLOW(S) &hArr; あるスコープ S' において、scope(r)=Sであるようなrefタイプのアルファベット r が存在し、tr(x, r, y)かつtr(y, a, z)となる遷移規則が存在する。</p>
<p>　くだけた言い方をすれば、FIRSTはスコープの開始を告げるアルファベット、FOLLOWはスコープの終了を告げるアルファベットです。すべてのスコープについてFIRSTとFOLLOWを計算します。これらは文脈自由文法からコンパイラをつくるときに使うFIRSTとFOLLOWに倣った概念です。</p>
<h2>Step 5　決定性チェック</h2>
<p>　RelaxNGCCでは、オートマトンが非決定的になる場合はサポートしていません。手をかければ先読みをしたりバックトラックをしたりといったことは理論的には可能ですが、そこまではやっていません。

</p>
<p>
　スコープ X がつくるオートマトンが非決定的になるのは、次のいずれかの条件を満たす状態 O が１つでも存在する場合です。

</p>
<ol>
<li>Oから同一のアルファベットで異なる状態へ遷移可能</li>
<li>refタイプのアルファベット r でOから遷移可能で、FIRST(scope(r))に含まれるアルファベットでも遷移可能</li>
<li>refタイプのアルファベット r, r' でOから遷移可能で、FIRST(scope(r))とFIRST(scope(r'))の両方に含まれるアルファベットが存在する</li>
<li>Oが受理状態で、FOLLOW(X)に含まれるアルファベットでOから遷移可能。これは厳密にはオートマトンの非決定性ではないですが、スコープの終端が判定できなくなるためRelaxNGCCで処理できないものの１つです。</li>
</ol>
<p>　２番目の条件は、次のような例であてはまります。choiceの先頭では、startElement[x]で遷移できますが、名前aのdefineのスコープのFIRSTにもstartElement[x]が含まれるからです。 </p>
<pre>
&lt;define name="a"&gt;
  &lt;element name="x"&gt;...&lt;/element&gt;
&lt;/define&gt;
&lt;start&gt;
  &lt;choice&gt;
    &lt;element name="x"&gt;...&lt;/element&gt;
    &lt;ref name="a"/&gt;
  &lt;/choice&gt;
&lt;/start&gt;
</pre>
<p>　４番目の条件は、次のような例であてはまります。名前aのスコープAの受理状態からはさらにstartElement[x]で遷移可能ですが、(*)の行を見るとFOLLOW(A)がstartElement[x]を含んでいるからです。</p>
<pre>
&lt;define name="a"&gt;
  &lt;oneOrMore&gt;&lt;element name="x"&gt;...&lt;/element&gt;&lt;/oneOrMore&gt;
&lt;/define&gt;
&lt;start&gt;
  &lt;ref name="a"/&gt;
  &lt;element name="x"&gt;...&lt;/element&gt; (*)
&lt;/start&gt;
</pre>
<p>　決定性チェックに失敗した場合、RelaxNGCCはそのことを示すメッセージを出力し終了します。</p>
<h2>Step 6　コード生成</h2>
<p>
　ここまできたら、いよいよコード生成です。状態遷移のトリガはstartElement, endElementなどのSAXイベントです。SAXのstartElementで名前 x を受け取ったら、アルファベットstartElement[x]を受け取ったことになります。ただしアトリビュートはstartElementの時点で通知されるだけなので、扱いを変える必要があります。次のルールを導入します。

</p>
<ul>
<li>startElementでアトリビュートの集合を受け取ったらスタックへプッシュする</li>
<li>endElementを受け取ったらスタックからポップする</li>
<li>オートマトンの状態遷移が起こるたびに、遷移先の状態が次のすべての条件
<ul>
<li>アトリビュートタイプのアルファベット x で遷移可能である</li>
<li>スタックのトップのアトリビュート集合に、xと同じ名前のアトリビュート a が存在する</li>
</ul>
を満たすかを調べ、その場合には x での遷移および aの値のテキスト v での遷移を行う。
</ul>

<p>また、スコープの開始と終了の処理のために次の処理を導入します。</p>
<ul>
<li>refタイプのアルファベット r で遷移可能な状態 O において、FIRST(scope(r))に含まれるアルファベット x を受け取ったら、
<ul>
<li>遷移先の状態 P を保存し、</li>
<li>現在状態をscope(r)の作るオートマトンの初期状態とし、,</li>
<li>xで遷移する。</li>
</ul>
<li>現在状態 O が受理状態で、FOLLOW(scope(O))に含まれるアルファベット x を受け取ったら、
<ul>
<li>保存してあった P を現在状態とし、</li>
<li>xで遷移する。</li>
</ul>
</ul>
<p>　SAXの言葉で言えば、スコープを開始するときにContentHandlerを置換し、スコープを終了するときにContentHandlerを復帰することになります。</p>
<hr>
<p align="right"><a href="index_ja.htm">RelaxNGCC home</a></p>
</body>
</html>